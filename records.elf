% A simple functional language extended with records.
% Computation and Deduction (2017), Anders Kiel Hovgaard.

% --- Natural numbers

nat : type. %name nat N.

0 : nat.
s : nat -> nat.

% Disequality
nat-neq : nat -> nat -> type.

nat-neq/s0 : nat-neq (s N) 0.
nat-neq/0s : nat-neq 0 (s N).
nat-neq/ss : nat-neq (s N1) (s N2)
              <- nat-neq N1 N2.


% --- Labels

label : type. %name label L.

label/nat : nat -> label.

label-eq  : label -> label -> type.
label-eq/ : label-eq (label/nat N) (label/nat N).

label-neq  : label -> label -> type.
label-neq/ : label-neq (label/nat N) (label/nat N')
              <- nat-neq N N'.


% --- Types

tp : type. %name tp T.
tp-rcd : type. %name tp-rcd TR.

tp/nat   : tp.
tp/arrow : tp -> tp -> tp.
tp/rcd   : tp-rcd -> tp.

tp-rcd/rnil  : tp-rcd.
tp-rcd/rcons : label -> tp -> tp-rcd -> tp-rcd.


% --- Syntax

exp : type. %name exp E.
rcd : type. %name rcd R.

num  : nat -> exp.
lam  : tp -> (exp -> exp) -> exp.
app  : exp -> exp -> exp.
fix  : (exp -> exp) -> exp.

% Records
rcde : rcd -> exp. % "record expression"
rsel : exp -> label -> exp.

rnil  : rcd.
rcons : label -> exp -> rcd -> rcd.

% Derived forms
pair : exp -> exp -> exp
  = [e1] [e2] rcde (rcons (label/nat 0) e1 (rcons (label/nat (s 0)) e2 rnil)).

fst : exp -> exp
  = [e] rsel e (label/nat 0).

snd : exp -> exp
  = [e] rsel e (label/nat (s 0)).


% Examples of abstract syntax involving records (used in later queries).
example-rcd : rcd = rcons (label/nat 0) (num 0)
                     (rcons (label/nat (s 0)) (lam tp/nat [x] x)
                        rnil).
example-rsel : exp = rsel (rcde example-rcd) (label/nat (s 0)).


% --- Notion of value

value : exp -> type. %name value VP.
value-rcd : rcd -> type. %name value-rcd VPR.

value/num  : value (num N).

value/lam  : value (lam T [x] E x).

value/rcde : value (rcde R)
              <- value-rcd R.

value-rcd/rnil  : value-rcd rnil.

value-rcd/rcons : value-rcd (rcons L V R)
                   <- value V
                   <- value-rcd R.

%query 1 * D : value (rcde example-rcd).

% Not a value because the component is beta-reducible.
%query 0 * D : value (rcde (rcons (label/nat 0)
                              (app (lam tp/nat [x] x) (num 0)) rnil)).

%query 0 * D : value (rsel (rcde (rcons (label/nat 0)
                                    (num 0) rnil)) (label/nat 0)).


% --- Judgments about labels and records

% Judgment that a label does not occur in a record type.
label-absent-tp : label -> tp-rcd -> type.

label-absent-tp/rnil  : label-absent-tp L tp-rcd/rnil.

label-absent-tp/rcons : label-absent-tp L (tp-rcd/rcons L' T TR)
                         <- label-neq L L'
                         <- label-absent-tp L TR.

% Well-formedness of (record) types: uniqueness of labels.
wellf-tp : tp -> type.
wellf-tp-rcd : tp-rcd -> type.

wellf-tp/nat   : wellf-tp tp/nat.

wellf-tp/arrow : wellf-tp (tp/arrow T T')
                  <- wellf-tp T
                  <- wellf-tp T'.

wellf-tp/rcd   : wellf-tp (tp/rcd TR)
                  <- wellf-tp-rcd TR.

wellf-tp-rcd/rnil  : wellf-tp-rcd tp-rcd/rnil.

wellf-tp-rcd/rcons : wellf-tp-rcd (tp-rcd/rcons L T TR)
                      <- wellf-tp T
                      <- label-absent-tp L TR
                      <- wellf-tp-rcd TR.

% Extracts the type at a given label from a record type.
extract-tp : label -> tp-rcd -> tp -> type.

extract-tp/eq  : extract-tp L (tp-rcd/rcons L' T TR) T
                  <- label-eq L L'.

extract-tp/neq : extract-tp L (tp-rcd/rcons L' T' TR) T
                  <- label-neq L L'
                  <- extract-tp L TR T.

% A simple example.
example-rcd-tp = tp-rcd/rcons (label/nat 0) tp/nat
                  (tp-rcd/rcons (label/nat (s 0)) (tp/arrow tp/nat tp/nat)
                     tp-rcd/rnil).
%query 1 * D : wellf-tp (tp/rcd example-rcd-tp).
%query 1 * D : extract-tp (label/nat (s 0)) example-rcd-tp
                          (tp/arrow tp/nat tp/nat).
%query 0 * D : extract-tp (label/nat (s (s 0))) example-rcd-tp T.


% Extracts the component with a given label in a record.
extract : label -> rcd -> exp -> type.

extract/eq  : extract L (rcons L' E R) E
               <- label-eq L L'.

extract/neq : extract L (rcons L' E R) E'
               <- label-neq L L'
               <- extract L R E'.

%query 1 * D : extract (label/nat 0) example-rcd E.
%query 0 * D : extract (label/nat (s (s 0))) example-rcd E.


% --- Typing judgment

of : exp -> tp -> type. %name of OP.
of-rcd : rcd -> tp-rcd -> type. %name of-rcd ORP.

of/num  : of (num N) tp/nat.

of/lam  : of (lam T [x] E x) (tp/arrow T T')
           <- wellf-tp T
           <- {x:exp} of x T -> of (E x) T'.

of/app  : of (app E1 E2) T'
           <- of E1 (tp/arrow T T')
           <- of E2 T.

of/fix  : of (fix [x] E x) T
           <- {x:exp} of x T -> of (E x) T.

% Records
of/rcde : of (rcde R) (tp/rcd TR)
           <- of-rcd R TR
           <- wellf-tp-rcd TR.  % or label-uniq R

of/rsel : of (rsel E L) T
           <- of E (tp/rcd TR)
           <- extract-tp L TR T.

of-rcd/rnil  : of-rcd rnil tp-rcd/rnil.

of-rcd/rcons : of-rcd (rcons L E R) (tp-rcd/rcons L T TR)
                <- of E T
                <- of-rcd R TR.

%query 1 * D : of (rcde example-rcd) T.
%query 1 * D : of example-rsel T.

% Ill-formed record with duplicate labels.
example-rcd-bad : rcd = rcons (label/nat 0) (num 0)
                         (rcons (label/nat (s 0)) (lam tp/nat [x] x)
                            (rcons (label/nat (s 0)) (num 0)
                               rnil)).
%query 0 * D : of (rcde example-rcd-bad) T.

% Example: ((lam x:T.x) {l0 = s 0, l1 = 0}).l0
ex-tp0 : tp = tp/rcd (tp-rcd/rcons (label/nat 0) tp/nat
                     (tp-rcd/rcons (label/nat (s 0)) tp/nat tp-rcd/rnil)).

example-rsel-app : exp
  = rsel (app (lam ex-tp0 [x] x)
            (rcde (rcons (label/nat 0) (num (s 0))
                     (rcons (label/nat (s 0)) (num 0) rnil))))
         (label/nat 0).

%query 1 * D : of example-rsel-app T.


%% Lemma: Given a record typing derivation and a record type extraction,
%%        we can construct a corresponding record component extraction.

extract-tp2exp : of-rcd R TR
                  -> extract-tp L TR T -> extract L R E -> type.
%mode extract-tp2exp +OPR +ExtTp -Ext.

- : extract-tp2exp (of-rcd/rcons ORP OP) (extract-tp/eq Q)
                   (extract/eq Q).

- : extract-tp2exp (of-rcd/rcons ORP OP) (extract-tp/neq ExtTp NQ)
                   (extract/neq Ext NQ)
     <- extract-tp2exp ORP ExtTp Ext.

%worlds () (extract-tp2exp _ _ _).
%total (ExtTp) (extract-tp2exp _ ExtTp _).

% From expression component extraction to type extraction.
extract-exp2tp : of-rcd R TR
                  -> extract L R E -> extract-tp L TR T -> type.
%mode extract-exp2tp +OPR +Ext -ExtTp.

- : extract-exp2tp (of-rcd/rcons ORP OP) (extract/eq Q) (extract-tp/eq Q).

- : extract-exp2tp (of-rcd/rcons ORP OP) (extract/neq Ext NQ) (extract-tp/neq ExtTp NQ)
     <- extract-exp2tp ORP Ext ExtTp.

%worlds () (extract-exp2tp _ _ _).
%total (Ext) (extract-exp2tp _ Ext _).


% --- Semantics

% Small-step semantics

step : exp -> exp -> type. %name step SP.
step-rcd : rcd -> rcd -> type. %name step SRP.

step/app1  : step (app E1 E2) (app E1' E2)
              <- step E1 E1'.

step/app2  : step (app V1 E2) (app V1 E2')
              <- value V1
              <- step E2 E2'.

step/app   : step (app (lam T [x] E0 x) V2) (E0 V2)
              <- value V2.

step/fix   : step (fix [x] E x) (E (fix [x] E x)).

step/rcde  : step (rcde R) (rcde R')
              <- step-rcd R R'.

step/rsel1 : step (rsel E L) (rsel E' L)
              <- step E E'.

step/rsel  : step (rsel (rcde V) L) V'
              <- value-rcd V
              <- extract L V V'.

step-rcd/rcons1 : step-rcd (rcons L E R) (rcons L E' R)
                   <- step E E'.

step-rcd/rcons  : step-rcd (rcons L V R) (rcons L V R')
                   <- value V
                   <- step-rcd R R'.

% Example expression which is not a value.
example-rcd' = rcde (rcons (label/nat 0) (app (lam tp/nat [x] x) (num 0))
                       (rcons (label/nat (s 0)) (app (lam tp/nat [x] x) (num 0))
                          rnil)).
%query 1 * D : step example-rcd' E'.


% Iterated step relation
steps : exp -> exp -> type. %name steps SS.

steps/0 : steps E E.

steps/m : steps E E'
           <- step E E''
           <- steps E'' E'.

% Small-step evaluation
stepsto : exp -> exp -> type.

stepsto/ : stepsto E V
            <- steps E V
            <- value V.

%query 1 * D : stepsto example-rcd' E'.



% --- Metatheorem: Progress

% An expression is "good" if it's a value of it can step.
good : exp -> type. %name good GP.

good/v : good V
          <- value V.

good/s : good E
          <- step E E'.

% Equivalent notion for records.
good-rcd : rcd -> type.

good-rcd/v : good-rcd V
              <- value-rcd V.

good-rcd/s : good-rcd R
              <- step-rcd R R'.

% Progress lemma for application (output factoring).
pgood-app : of E1 (tp/arrow T T')
                -> good E1 -> good E2 -> good (app E1 E2) -> type.
%mode pgood-app +OP1 +GP1 +GP2 -GP3.

% We analyze each case where E1 and E2 are values or can step, respectively.
- : pgood-app _ (good/s SP) GP2 (good/s (step/app1 SP)).
- : pgood-app _ (good/v VP) (good/s SP) (good/s (step/app2 SP VP)).
- : pgood-app _ (good/v value/lam) (good/v VP) (good/s (step/app VP)).

%worlds () (pgood-app _ _ _ _).
%total {} (pgood-app _ _ _ _).

% Equivalent lemma for records.
pgood-rcd : of-rcd (rcons L E R) (tp-rcd/rcons L T TR)
            -> good E -> good-rcd R -> good-rcd (rcons L E R) -> type.
%mode pgood-rcd +ORP +GP1 +GP2 -GP3.

- : pgood-rcd _ (good/s SP) GP (good-rcd/s (step-rcd/rcons1 SP)).
- : pgood-rcd _ (good/v VP) (good-rcd/s SP) (good-rcd/s (step-rcd/rcons SP VP)).
- : pgood-rcd _ (good/v VP1) (good-rcd/v VP2) (good-rcd/v (value-rcd/rcons VP2 VP1)).

%worlds () (pgood-rcd _ _ _ _).
%total {} (pgood-rcd _ _ _ _).


pgood-rsel : extract-tp L TR T
              -> of E (tp/rcd TR) -> good E -> good (rsel E L) -> type.
%mode pgood-rsel +E +OP +GP1 -GP2.

- : pgood-rsel Ext OP (good/s SP) (good/s (step/rsel1 SP)).

- : pgood-rsel ExtTp (of/rcde WF ORP) (good/v (value/rcde VP))
               (good/s (step/rsel Ext VP))
     <- extract-tp2exp ORP ExtTp Ext.

%worlds () (pgood-rsel _ _ _ _).
%total {} (pgood-rsel _ _ _ _).


pgood-rcde : good-rcd R -> good (rcde R) -> type.
%mode pgood-rcde +GP1 -GP2.

- : pgood-rcde (good-rcd/s SP) (good/s (step/rcde SP)).
- : pgood-rcde (good-rcd/v VP) (good/v (value/rcde VP)).

%worlds () (pgood-rcde _ _).
%total {} (pgood-rcde _ _).


%% Progress

progress : of E T -> good E -> type.
%mode progress +OP -GP.

progress-rcd : of-rcd R TR -> good-rcd R -> type.
%mode progress-rcd +OP -GP.

progress/num  : progress of/num (good/v value/num).

progress/lam  : progress (of/lam OP WellF) (good/v value/lam).

progress/app  : progress (of/app OP2 OP1) GP
                 <- progress OP1 GP1
                 <- progress OP2 GP2
                 <- pgood-app OP1 GP1 GP2 GP.

progress/fix  : progress (of/fix OP) (good/s step/fix).

progress/rcde : progress (of/rcde WFR ORP) GP
                 <- progress-rcd ORP GP'
                 <- pgood-rcde GP' GP.

progress/rsel : progress (of/rsel ExtTp OP) GP
                 <- progress OP GP1
                 <- pgood-rsel ExtTp OP GP1 GP.

progress-rcd/rnil  : progress-rcd of-rcd/rnil (good-rcd/v value-rcd/rnil).

progress-rcd/rcons : progress-rcd (of-rcd/rcons OPR OP) GP
                      <- progress OP GP1
                      <- progress-rcd OPR GP2
                      <- pgood-rcd (of-rcd/rcons OPR OP) GP1 GP2 GP.

%worlds () (progress _ _) (progress-rcd _ _).
%total (OP OPR) (progress OP _) (progress-rcd OPR _).


% --- Reasoning from absurdity

uninhabited : type.
%freeze uninhabited.

% It is absurd that two identical natural numbers should be not equal.
neq-nat-uninhabited : nat-neq N N -> uninhabited -> type.
%mode neq-nat-uninhabited +D1 -D2.
- : neq-nat-uninhabited (nat-neq/ss NE) U
     <- neq-nat-uninhabited NE U.
%worlds () (neq-nat-uninhabited _ _).
%total (D) (neq-nat-uninhabited D _).

% Similarly for labels.
label-neq-uninhabited : label-neq L L -> uninhabited -> type.
%mode label-neq-uninhabited +D1 -D2.
- : label-neq-uninhabited (label-neq/ NE) U
     <- neq-nat-uninhabited NE U.
%worlds () (label-neq-uninhabited _ _).
%total {} (label-neq-uninhabited _ _).

% It is absurd if a label does not occur in a record type
% and yet a type at the label can be extracted.
absent-extract-uninhabited : label-absent-tp L TR
                              -> extract-tp L TR T -> uninhabited -> type.
%mode absent-extract-uninhabited +LabAbs +ExtTp -U.

- : absent-extract-uninhabited (label-absent-tp/rcons LabAbs' Neq)
                               (extract-tp/eq Eq) U
     <- label-neq-uninhabited Neq U.

- : absent-extract-uninhabited (label-absent-tp/rcons LabAbs' Neq)
                               (extract-tp/neq ExtTp' Neq') U
     <- absent-extract-uninhabited LabAbs' ExtTp' U.

%worlds () (absent-extract-uninhabited _ _ _).
%total (ExtTp) (absent-extract-uninhabited _ ExtTp _).

% From absurdity, we can conclude any typing derivation.
uninhabited-of : {E} {T} uninhabited -> of E T -> type.
%mode uninhabited-of +E +T +D -D'.
%worlds () (uninhabited-of _ _ _ _).
%total {} (uninhabited-of _ _ _ _).


% --- Preservation

% Given a record typing derivation, a well-formedness derivation for its type,
% and component and type extractions for the same label, we can extract the
% typing derivation for the expression and type at that particular label.
extract-comp-tp : of-rcd R TR -> wellf-tp-rcd TR
                   -> extract L R E -> extract-tp L TR T -> of E T -> type.
%mode extract-comp-tp +ORP +WF +Ext +ExtTp -OP.

- : extract-comp-tp (of-rcd/rcons OPR OP)
                    (wellf-tp-rcd/rcons WellRcdTp LabAbs WellTp)
                    (extract/eq _) (extract-tp/eq _) OP.

- : extract-comp-tp (of-rcd/rcons OPR OP')
                    (wellf-tp-rcd/rcons WellRcdTp LabAbs WellTp)
                    (extract/neq Ext Q) (extract-tp/neq ExtTp Q') OP
     <- extract-comp-tp OPR WellRcdTp Ext ExtTp OP.

- : extract-comp-tp (of-rcd/rcons OPR OP')
                    (wellf-tp-rcd/rcons WellRcdTp LabAbs WellTp)
                    (extract/eq Q : extract L _ E)
                    (extract-tp/neq ExtTp Neq : extract-tp L _ T)
                    OP
     <- absent-extract-uninhabited LabAbs ExtTp U
     <- uninhabited-of E T U OP.

- : extract-comp-tp (of-rcd/rcons ORP OP')
                    (wellf-tp-rcd/rcons WellRcdTp LabAbs WellTp)
                    (extract/neq Ext Neq : extract L _ E)
                    (extract-tp/eq Eq : extract-tp L _ T)
                    OP
       <- extract-exp2tp ORP Ext ExtTp
       <- absent-extract-uninhabited LabAbs ExtTp U
       <- uninhabited-of E T U OP.

%worlds () (extract-comp-tp _ _ _ _ _).
%total (ORP) (extract-comp-tp ORP _ _ _ _).


%% Preservation lemma

preserv : step E E' -> of E T -> of E' T -> type.
%mode preserv +SP +OP -OP'.

preserv-rcd : step-rcd R R' -> of-rcd R TR -> of-rcd R' TR -> type.
%mode preserv-rcd +SRP +ORP -ORP'.

preserv/app1  : preserv (step/app1 SP1) (of/app OP2 OP1) (of/app OP2 OP1')
                 <- preserv SP1 OP1 OP1'.

preserv/app2  : preserv (step/app2 SP2 VP1) (of/app OP2 OP1) (of/app OP2' OP1)
                 <- preserv SP2 OP2 OP2'.

preserv/app   : preserv (step/app VP2)
                        (of/app (OP2 : of E2 T)
                           (of/lam (OP1 : {x:exp} of x T -> of (E x) T') WF))
                        (OP1 E2 OP2).

preserv/fix   : preserv step/fix
                        (of/fix [x] [dx] OP x dx)
                        (OP (fix [x] E x) (of/fix OP)).

preserv/rcde  : preserv (step/rcde SRP) (of/rcde WF ORP) (of/rcde WF ORP')
                 <- preserv-rcd SRP ORP ORP'.

preserv/rsel1 : preserv (step/rsel1 SP) (of/rsel ExtTp OP) (of/rsel ExtTp OP')
                 <- preserv SP OP OP'.

preserv/rsel  : preserv (step/rsel Ext VP) (of/rsel ExtTp (of/rcde WF ORP)) OP
                 <- extract-comp-tp ORP WF Ext ExtTp OP.

preserv-rcd/rcons1 : preserv-rcd (step-rcd/rcons1 SP)
                                 (of-rcd/rcons ORP OP)
                                 (of-rcd/rcons ORP OP')
                      <- preserv SP OP OP'.

preserv-rcd/rcons  : preserv-rcd (step-rcd/rcons SRP VP)
                                 (of-rcd/rcons ORP OP)
                                 (of-rcd/rcons ORP' OP)
                      <- preserv-rcd SRP ORP ORP'.

%worlds () (preserv _ _ _) (preserv-rcd _ _ _).
%total (SP SRP) (preserv SP _ _) (preserv-rcd SRP _ _).
